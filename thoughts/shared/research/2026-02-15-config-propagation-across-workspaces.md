---
date: 2026-02-15T06:30:00Z
researcher: jeevan
git_commit: b96a25d
branch: main
repository: dual
topic: "Configuration file propagation across workspaces: solutions for sharing .env, .vercel, and platform config"
tags: [research, codebase, config, env-vars, workspaces, symlinks, docker, provisioning]
status: complete
last_updated: 2026-02-15
last_updated_by: jeevan
---

# Research: Configuration File Propagation Across Workspaces

**Date**: 2026-02-15T06:30:00Z
**Researcher**: jeevan
**Git Commit**: b96a25d
**Branch**: main
**Repository**: dual

## Research Question

How can Dual ensure that configuration files (`.env`, `.vercel/`, platform-specific configs) propagate from a "main" workspace to all branch workspaces automatically? What are the different solution architectures, and what types of config files exist across development ecosystems?

## Summary

Dual's workspace model creates **full git clones** per branch. Gitignored files (`.env.local`, `.vercel/`, `.netlify/`) are **lost** on clone — they exist only in the workspace where they were created. The user's core problem: running `vercel pull` on `main` generates `.vercel/` with credentials, but `dual create repo feat/auth` produces a clone that has no `.vercel/` directory.

Eight solution architectures were evaluated. The recommended approach is a **hybrid of symlinks + shared directory + optional manifest**, which provides instant propagation, branch-specific overrides, and works within Dual's existing Docker bind-mount architecture.

## Detailed Findings

### 1. The Root Problem: Git Clone Drops Gitignored Files

When `dual create` registers a branch workspace and `dual launch` clones it (`src/clone.rs:27-74`), the clone operation is `git clone -b <branch> <url> <dir>`. This produces a complete git history but **no gitignored files**.

Files lost on clone:
- `.env`, `.env.local`, `.env.development.local` (secrets)
- `.vercel/` directory (project link + pulled env vars)
- `.netlify/` directory (site link)
- `.supabase/` directory (local DB state)
- `node_modules/` (handled separately via Docker anonymous volume)
- Any generated credentials or platform state

Files that survive (committed to git):
- `.dual.toml` (image, ports, setup, env)
- `vercel.json`, `netlify.toml`, `fly.toml` (platform build config)
- `.nvmrc`, `.tool-versions`, `rust-toolchain.toml` (version pinning)
- `turbo.json`, `nx.json` (build orchestration)
- `.editorconfig`, `.vscode/settings.json` (editor config)

### 2. Complete Ecosystem of Config Files by Category

#### Environment Variable Files
| File | Gitignored | Contains Secrets | Generation |
|------|-----------|------------------|------------|
| `.env` | Yes | Yes | Manual |
| `.env.local` | Yes | Yes | Manual or `vercel env pull` |
| `.env.development` | Sometimes | No (placeholders) | Manual |
| `.env.development.local` | Yes | Yes | `vercel env pull` |
| `.env.production` | Sometimes | No (placeholders) | Manual |
| `.env.example` | No (template) | No | Manual |

#### Platform/Deployment Directories (Generated, Gitignored)
| Directory | Generated By | Contains |
|-----------|-------------|----------|
| `.vercel/` | `vercel link` / `vercel pull` | Project link, pulled env vars |
| `.netlify/` | `netlify link` | Site ID, API tokens |
| `.supabase/` | `supabase init` | Local DB state |
| `.wrangler/` | `wrangler login` | Auth state, cache |
| `.firebase/` | `firebase deploy` | Hosting cache |
| `.aws-sam/` | `sam build` | Build artifacts |

#### Platform Config Files (Committed)
| File | Platform | Purpose |
|------|----------|---------|
| `vercel.json` | Vercel | Build/routing config |
| `netlify.toml` | Netlify | Build/redirect config |
| `fly.toml` | Fly.io | App config |
| `wrangler.toml` | Cloudflare | Worker config |
| `firebase.json` | Firebase | Project config |
| `docker-compose.yml` | Docker | Service definitions |

#### Secrets Files (Gitignored)
| File | Tool | Purpose |
|------|------|---------|
| `.dev.vars` | Cloudflare Workers | Local dev secrets |
| `prisma/.env` | Prisma | Database URL |
| `.pgpass` | PostgreSQL | DB credentials |
| `.env.tpl` + `.env` | 1Password CLI | Template + generated secrets |

#### Global Credentials (Host-Level, Not Per-Project)
| Path | Tool | Workspace Handling |
|------|------|--------------------|
| `~/.npmrc` | npm | Mount read-only to container |
| `~/.aws/` | AWS CLI | Mount read-only or use IAM |
| `~/.ssh/` | Git/SSH | Mount read-only |
| `~/.cargo/credentials` | Cargo | Mount read-only |
| `~/.pypirc` | PyPI | Mount read-only |
| `~/.gitconfig` | Git | Mount read-only |

#### Version Pinning Files (Committed, Clone Normally)
`.nvmrc`, `.node-version`, `.python-version`, `.ruby-version`, `.tool-versions` (asdf), `rust-toolchain.toml`

### 3. Current Workspace Architecture

**Main workspace** (`dual add`): Points to user's existing directory via `path: Some(...)`. All files present.

**Branch workspace** (`dual create` + `dual launch`): Full `git clone` into `~/.dual/workspaces/{repo}/{encoded_branch}/`. Gitignored files missing.

**Container bind mount** (`src/container.rs:147-167`): `docker create -v {workspace_dir}:/workspace`. One bind mount, no additional volume mounts for shared config.

**No relationship between workspaces**: `WorkspaceEntry` has no `parent` or `source` field. Branch workspaces inherit the git URL but nothing else.

### 4. Eight Solution Architectures

#### Solution A: Symlinks to Source Workspace

After cloning a branch workspace, create symlinks from the branch directory to the main workspace's gitignored files.

```
~/.dual/workspaces/myrepo/feat__auth/.vercel@ -> /Users/dev/myrepo/.vercel
~/.dual/workspaces/myrepo/feat__auth/.env.local@ -> /Users/dev/myrepo/.env.local
```

**Pros**: Zero overhead, instant propagation, simple implementation.
**Cons**: Symlinks may break if main workspace moves. Docker bind mount needs care (symlinks pointing outside mount). All-or-nothing per file (no partial overrides within a directory). Windows compatibility issues.

#### Solution B: Overlay Filesystem

Layer a read-only "shared config" directory under a writable branch directory using OverlayFS.

**Pros**: True copy-on-write, per-file override capability.
**Cons**: Requires root/privileged containers. Linux-only. Complex mount management. Debugging difficulty.

**Verdict**: Poor fit. Breaks Dual's cross-platform and unprivileged-container goals.

#### Solution C: Copy-on-Create

Copy specific files from the main workspace into each new branch workspace at creation time.

```rust
// After git clone completes
copy_if_exists(main_workspace.join(".vercel"), branch_workspace.join(".vercel"))?;
copy_if_exists(main_workspace.join(".env.local"), branch_workspace.join(".env.local"))?;
```

**Pros**: Simple, cross-platform, full isolation, debuggable.
**Cons**: Stale configuration (updates to main don't propagate). Requires manual `dual sync` after updating main. Disk duplication.

#### Solution D: Shared Directory + Symlinks (Hybrid)

Store canonical config in `~/.dual/shared/{repo}/`. Both main and branch workspaces symlink to this location.

```
~/.dual/shared/myrepo/
  ├── .vercel/          # Single source of truth
  └── .env.local

~/.dual/workspaces/myrepo/feat__auth/
  ├── .vercel@ -> ~/.dual/shared/myrepo/.vercel
  └── .env.local@ -> ~/.dual/shared/myrepo/.env.local
```

**Pros**: Single source of truth. Instant propagation. Clear separation. Easy Docker integration (mount shared dir as additional volume). Branch override by replacing symlink with real file.
**Cons**: Tools expect `.vercel/` in project root (symlinks satisfy this). Docker individual-file mounts have edge cases on some versions.

#### Solution E: Git-Based (Submodules, git-crypt)

Use git mechanisms to version-control and distribute shared config.

**Verdict**: Poor fit. These files are gitignored for good reason (secrets). Git operations required to propagate changes defeats the "just works" requirement.

#### Solution F: File Watching Daemon

Background process monitors main workspace and syncs changes to all branch workspaces in real-time.

**Pros**: Fully automatic, real-time updates.
**Cons**: Another daemon to manage. Resource usage. Sync race conditions. Debugging complexity.

**Verdict**: Viable as opt-in advanced feature, not as default.

#### Solution G: Docker Volume Mounts

Mount shared config as additional Docker volumes alongside the workspace bind mount.

```bash
docker create \
  -v {workspace_dir}:/workspace \
  -v {shared_dir}/.vercel:/workspace/.vercel:ro \
  -v {shared_dir}/.env.local:/workspace/.env.local:ro \
  ...
```

**Pros**: Docker-native, no symlinks needed, read-only option.
**Cons**: Config only visible inside container (not on host in workspace dir). Individual file mounts have edge cases. Requires container recreation on config changes.

#### Solution H: Manifest/Declaration File

A `.dual.toml` section declaring which files should be shared and how.

```toml
[shared]
symlink = [".vercel", ".env.local"]
source = "main"
```

**Pros**: User-controlled, explicit, versionable, extensible.
**Cons**: Requires user to set up manifest. Another config surface.

### 5. Recommended Hybrid Architecture

Combine Solutions D (Shared Directory), A (Symlinks), and H (Manifest) in phases:

**Phase 1 — Shared Directory + Auto-Symlinks**:
- On `dual add` (main workspace), move gitignored config to `~/.dual/shared/{repo}/`, create symlinks back.
- On `dual create`/`dual launch` (branch workspace), after clone, create symlinks to `~/.dual/shared/{repo}/`.
- User runs `vercel pull` in main workspace → updates `~/.dual/shared/{repo}/.vercel/` → all branches see it instantly.

**Phase 2 — `.dual.toml` Manifest**:
- Add `[shared]` section to `.dual.toml` for per-project customization.
- Default behavior works without manifest (common files auto-detected).
- Power users can declare additional files, override strategy, etc.

**Phase 3 — Docker Volume Mounts (Optional)**:
- For container-only visibility, mount `~/.dual/shared/{repo}/` as an additional read-only volume.
- This ensures container processes see shared config even without host-side symlinks.

### 6. Data Flow with Recommended Architecture

```
User runs `vercel pull` in main workspace
    ↓
.vercel/ created in ~/.dual/shared/myrepo/.vercel/
    ↓ (symlink in main workspace)
/Users/dev/myrepo/.vercel@ -> ~/.dual/shared/myrepo/.vercel
    ↓ (symlinks in branch workspaces)
~/.dual/workspaces/myrepo/feat__auth/.vercel@ -> ~/.dual/shared/myrepo/.vercel
~/.dual/workspaces/myrepo/fix__bug/.vercel@ -> ~/.dual/shared/myrepo/.vercel
    ↓
All workspaces see updated .vercel/ instantly
    ↓
Docker containers bind-mount workspace dirs → see symlinks → see shared config
```

**Branch override flow**:
```
User needs different .env.local for feat__auth
    ↓
rm ~/.dual/workspaces/myrepo/feat__auth/.env.local   # remove symlink
    ↓
Create real file: ~/.dual/workspaces/myrepo/feat__auth/.env.local
    ↓
feat__auth uses its own .env.local, all other branches still use shared
```

## Code References

- `src/main.rs:57-123` — `cmd_add()` registers main workspace with `path: Some(...)`
- `src/main.rs:126-173` — `cmd_create()` registers branch workspace with `path: None`
- `src/main.rs:176-275` — `cmd_launch()` resolves workspace, clones if needed, creates container
- `src/main.rs:224` — `load_hints()` reads `.dual.toml`
- `src/main.rs:230` — Only `hints.image` passed to container, `hints.env` dropped
- `src/clone.rs:27-74` — `clone_workspace()` runs `git clone -b <branch>`, gitignored files lost
- `src/container.rs:20-36` — `container::create()` with single bind mount, no shared config mount
- `src/container.rs:147-167` — `build_create_args()` fixed Docker args, no env var injection
- `src/config.rs:8-25` — `RepoHints` struct with unimplemented `env` and `setup` fields
- `src/state.rs:20-35` — `WorkspaceEntry` struct with no parent/source reference

## Architecture Documentation

### Implementation Requirements for Recommended Approach

1. **New module**: `src/shared.rs` — Manage `~/.dual/shared/{repo}/` directory
   - `ensure_shared_dir(repo: &str) -> PathBuf`
   - `link_shared_config(workspace_dir: &Path, shared_dir: &Path, patterns: &[&str])`
   - `init_shared_from_workspace(workspace_dir: &Path, shared_dir: &Path, patterns: &[&str])`

2. **Modify `cmd_add()`**: After creating `.dual.toml`, initialize shared directory if gitignored config files exist in the repo root.

3. **Modify `clone_workspace()` or `cmd_launch()`**: After clone, create symlinks to shared directory.

4. **Modify `container::create()`**: Optionally add `-v ~/.dual/shared/{repo}:/dual-shared:ro` for container-side access.

5. **New `.dual.toml` section**:
   ```toml
   [shared]
   files = [".vercel", ".env.local", ".env"]
   ```

6. **New CLI command**: `dual sync [workspace]` — Force re-symlink from shared directory (useful after shared dir is populated for the first time).

### Default Shared File Patterns

Without a `[shared]` section in `.dual.toml`, Dual should auto-share these common patterns:
- `.env` / `.env.local` / `.env.*.local`
- `.vercel/`
- `.netlify/`
- `.dev.vars`

### Edge Cases to Handle

1. **Main workspace doesn't exist yet**: Branch created before main. Shared dir is empty. Symlinks point to nothing (dangling). Need lazy initialization — create symlinks on launch if shared dir has content.

2. **Docker symlink resolution**: Docker bind mounts follow symlinks on the host. If `.vercel/` is a symlink in the workspace dir, Docker resolves it and mounts the target. This works correctly.

3. **Cross-filesystem symlinks**: If `~/.dual/shared/` and workspace dirs are on different filesystems, symlinks still work (unlike hardlinks).

4. **Atomic updates**: `vercel pull` writes to `.vercel/` which is a symlink → writes go to `~/.dual/shared/myrepo/.vercel/`. All workspaces see the update atomically.

## Historical Context (from thoughts/)

- `thoughts/shared/research/2026-02-15-env-vars-plugin-infrastructure.md` — Identifies env var schema exists but is never wired. `hints.env` loaded and dropped at `src/main.rs:224-230`. No plugin system exists.
- `thoughts/shared/research/2026-02-13-BUILD-config.md` — Config module design. `.dual.toml` provides data (image, ports, setup, env), not behavior.
- `thoughts/shared/research/2026-02-13-BUILD-container.md` — Container module. Documents Docker `-e KEY=VALUE` support. Current implementation uses no `-e` flags.
- `thoughts/shared/research/2026-02-13-BUILD-clone.md` — Clone module. Full `git clone` strategy chosen over worktrees to avoid lock contention.
- `thoughts/shared/research/2026-02-05-ARCH-bind-mount-visibility.md` — macOS bind mount visibility research.
- `thoughts/ARCHITECTURE.md` — 27/27 spec claims validated. Notes credential separation (host vs container).
- `thoughts/BUILD.md` — MVP 14/14 modules complete. No shared config module planned or built.

## Related Research

- `thoughts/shared/research/2026-02-15-env-vars-plugin-infrastructure.md` — Companion document covering the unimplemented `[env]` section and lack of extensibility.

## Open Questions

1. **Initialization flow**: Should `dual add` automatically scan for gitignored config files and move them to `~/.dual/shared/`? Or should users explicitly run `dual share .vercel .env.local`?
2. **Bidirectional sync**: If a user modifies `.env.local` in a branch workspace that uses a symlink, the change propagates to all workspaces. Is this desired, or should modifications be per-workspace by default?
3. **Secret rotation**: When shared secrets change (e.g., daily `vercel pull`), should running containers be notified? Or is it sufficient that the next `docker exec` sees the updated files?
4. **Windows support**: Symlinks on Windows require developer mode or admin privileges. Should Dual fall back to copy-on-create on Windows?
5. **Scope of defaults**: Should Dual auto-detect common patterns (`.env*`, `.vercel/`) or require explicit declaration in `.dual.toml`? Auto-detection is more magical but less predictable.
