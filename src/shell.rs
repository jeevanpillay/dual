/// Default commands that route to the container.
const CONTAINER_COMMANDS: &[&str] = &[
    "npm", "npx", "pnpm", "node", "python", "python3", "pip", "pip3", "curl", "make",
];

/// Where a command should execute.
#[derive(Debug, Clone, PartialEq)]
pub enum RouteTarget {
    Container,
    Host,
}

/// Classify a command as host or container.
///
/// Default rules from SPEC.md:
/// - npm/pnpm/node/python/curl etc → container
/// - Everything else → host
pub fn classify(command: &str) -> RouteTarget {
    // Extract the base command name (strip path prefix)
    let base = command.rsplit('/').next().unwrap_or(command);

    if CONTAINER_COMMANDS.contains(&base) {
        RouteTarget::Container
    } else {
        RouteTarget::Host
    }
}

/// Generate shell RC content that intercepts runtime commands for a workspace.
///
/// The generated content defines shell functions that wrap `docker exec`
/// for each command that should route to the container. These functions
/// handle TTY detection automatically.
///
/// # Arguments
/// * `container_name` - The Docker container name (e.g. "dual-lightfast-main")
pub fn generate_rc(container_name: &str) -> String {
    let mut rc = String::new();

    rc.push_str("# Generated by dual — do not edit\n");
    rc.push_str(&format!(
        "# Shell interceptors for container: {container_name}\n\n"
    ));

    // Set the container name as an environment variable for reference
    rc.push_str(&format!("export DUAL_CONTAINER=\"{container_name}\"\n\n"));

    // Generate a function for each container command
    for cmd in CONTAINER_COMMANDS {
        rc.push_str(&generate_function(cmd, container_name));
        rc.push('\n');
    }

    rc
}

/// Generate a single shell function that intercepts a command.
///
/// The function:
/// - Detects if stdout is a TTY and passes -t to docker exec if so
/// - Forwards all arguments to the command inside the container
/// - Preserves exit codes
fn generate_function(command: &str, container_name: &str) -> String {
    format!(
        r#"{command}() {{
    if [ -t 1 ]; then
        command docker exec -t -w /workspace {container_name} {command} "$@"
    else
        command docker exec -w /workspace {container_name} {command} "$@"
    fi
}}
"#
    )
}

/// Generate a shell command to source the RC content from a string.
/// Useful for injecting into tmux pane creation.
pub fn source_command(container_name: &str) -> String {
    format!("eval \"$(dual shell-rc {container_name})\"")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classify_container_commands() {
        assert_eq!(classify("npm"), RouteTarget::Container);
        assert_eq!(classify("npx"), RouteTarget::Container);
        assert_eq!(classify("pnpm"), RouteTarget::Container);
        assert_eq!(classify("node"), RouteTarget::Container);
        assert_eq!(classify("python"), RouteTarget::Container);
        assert_eq!(classify("python3"), RouteTarget::Container);
        assert_eq!(classify("pip"), RouteTarget::Container);
        assert_eq!(classify("curl"), RouteTarget::Container);
        assert_eq!(classify("make"), RouteTarget::Container);
    }

    #[test]
    fn classify_host_commands() {
        assert_eq!(classify("git"), RouteTarget::Host);
        assert_eq!(classify("cat"), RouteTarget::Host);
        assert_eq!(classify("ls"), RouteTarget::Host);
        assert_eq!(classify("vim"), RouteTarget::Host);
        assert_eq!(classify("nvim"), RouteTarget::Host);
        assert_eq!(classify("ssh"), RouteTarget::Host);
    }

    #[test]
    fn classify_strips_path_prefix() {
        assert_eq!(classify("/usr/bin/npm"), RouteTarget::Container);
        assert_eq!(classify("/usr/local/bin/node"), RouteTarget::Container);
        assert_eq!(classify("/usr/bin/git"), RouteTarget::Host);
    }

    #[test]
    fn generate_rc_contains_functions() {
        let rc = generate_rc("dual-lightfast-main");

        // Should contain the container name export
        assert!(rc.contains("export DUAL_CONTAINER=\"dual-lightfast-main\""));

        // Should contain functions for all container commands
        assert!(rc.contains("npm()"));
        assert!(rc.contains("npx()"));
        assert!(rc.contains("pnpm()"));
        assert!(rc.contains("node()"));
        assert!(rc.contains("python()"));
        assert!(rc.contains("curl()"));
    }

    #[test]
    fn generate_rc_has_tty_detection() {
        let rc = generate_rc("dual-lightfast-main");
        assert!(rc.contains("if [ -t 1 ]; then"));
        assert!(rc.contains("docker exec -t"));
    }

    #[test]
    fn generate_rc_uses_correct_container() {
        let rc = generate_rc("dual-agent-os-feat__memory");
        assert!(rc.contains("dual-agent-os-feat__memory"));
        // Every function should reference this container
        for cmd in CONTAINER_COMMANDS {
            assert!(rc.contains(&format!(
                "command docker exec -t -w /workspace dual-agent-os-feat__memory {cmd}"
            )));
        }
    }

    #[test]
    fn generated_function_preserves_args() {
        let func = generate_function("npm", "dual-test");
        assert!(func.contains("\"$@\""));
    }

    #[test]
    fn source_command_format() {
        let cmd = source_command("dual-lightfast-main");
        assert_eq!(cmd, "eval \"$(dual shell-rc dual-lightfast-main)\"");
    }
}
