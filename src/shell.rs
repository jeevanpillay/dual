/// Default commands that route to the container.
const CONTAINER_COMMANDS: &[&str] = &[
    "npm", "npx", "pnpm", "node", "python", "python3", "pip", "pip3", "curl", "make",
];

/// Where a command should execute.
#[derive(Debug, Clone, PartialEq)]
pub enum RouteTarget {
    Container,
    Host,
}

/// Classify a command as host or container.
///
/// Default rules from SPEC.md:
/// - npm/pnpm/node/python/curl etc → container
/// - Everything else → host
pub fn classify(command: &str) -> RouteTarget {
    // Extract the base command name (strip path prefix)
    let base = command.rsplit('/').next().unwrap_or(command);

    if CONTAINER_COMMANDS.contains(&base) {
        RouteTarget::Container
    } else {
        RouteTarget::Host
    }
}

/// Generate shell RC content that intercepts runtime commands for a workspace.
///
/// The generated content defines shell functions that wrap `docker exec`
/// for each command that should route to the container. These functions
/// handle TTY detection automatically.
///
/// # Arguments
/// * `container_name` - The Docker container name (e.g. "dual-lightfast-main")
/// * `extra_commands` - Additional commands to route to the container
pub fn generate_rc(container_name: &str, extra_commands: &[String]) -> String {
    let mut rc = String::new();

    rc.push_str("# Generated by dual — do not edit\n");
    rc.push_str(&format!(
        "# Shell interceptors for container: {container_name}\n\n"
    ));

    // Set the container name as an environment variable for reference
    rc.push_str(&format!("export DUAL_CONTAINER=\"{container_name}\"\n\n"));

    // Generate a function for each default container command
    for cmd in CONTAINER_COMMANDS {
        rc.push_str(&generate_function(cmd, container_name));
        rc.push('\n');
    }

    // Generate a function for each extra command
    for cmd in extra_commands {
        if !CONTAINER_COMMANDS.contains(&cmd.as_str()) {
            rc.push_str(&generate_function(cmd, container_name));
            rc.push('\n');
        }
    }

    rc
}

/// Generate a single shell function that intercepts a command.
///
/// The function:
/// - Detects if stdout is a TTY and passes -t to docker exec if so
/// - Forwards all arguments to the command inside the container
/// - Preserves exit codes
fn generate_function(command: &str, container_name: &str) -> String {
    format!(
        r#"{command}() {{
    if [ -t 1 ]; then
        command docker exec -t -w /workspace {container_name} {command} "$@"
    else
        command docker exec -w /workspace {container_name} {command} "$@"
    fi
}}
"#
    )
}

/// Generate a shell command to source the RC content from a string.
/// Useful for injecting into tmux pane creation.
pub fn source_command(container_name: &str) -> String {
    format!("eval \"$(dual shell-rc {container_name})\"")
}

/// Write the shell RC to a file and return the path.
/// RC files are written to ~/.config/dual/rc/{container_name}.sh
pub fn write_rc_file(
    container_name: &str,
    extra_commands: &[String],
) -> Result<std::path::PathBuf, std::io::Error> {
    let rc_dir = dirs::config_dir()
        .unwrap_or_else(|| std::path::PathBuf::from(".config"))
        .join("dual")
        .join("rc");
    std::fs::create_dir_all(&rc_dir)?;

    let rc_path = rc_dir.join(format!("{container_name}.sh"));
    let rc_content = generate_rc(container_name, extra_commands);
    std::fs::write(&rc_path, rc_content)?;

    Ok(rc_path)
}

/// Get the source command for an RC file path.
pub fn source_file_command(rc_path: &std::path::Path) -> String {
    format!("source {}", rc_path.display())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn classify_container_commands() {
        assert_eq!(classify("npm"), RouteTarget::Container);
        assert_eq!(classify("npx"), RouteTarget::Container);
        assert_eq!(classify("pnpm"), RouteTarget::Container);
        assert_eq!(classify("node"), RouteTarget::Container);
        assert_eq!(classify("python"), RouteTarget::Container);
        assert_eq!(classify("python3"), RouteTarget::Container);
        assert_eq!(classify("pip"), RouteTarget::Container);
        assert_eq!(classify("curl"), RouteTarget::Container);
        assert_eq!(classify("make"), RouteTarget::Container);
    }

    #[test]
    fn classify_host_commands() {
        assert_eq!(classify("git"), RouteTarget::Host);
        assert_eq!(classify("cat"), RouteTarget::Host);
        assert_eq!(classify("ls"), RouteTarget::Host);
        assert_eq!(classify("vim"), RouteTarget::Host);
        assert_eq!(classify("nvim"), RouteTarget::Host);
        assert_eq!(classify("ssh"), RouteTarget::Host);
    }

    #[test]
    fn classify_strips_path_prefix() {
        assert_eq!(classify("/usr/bin/npm"), RouteTarget::Container);
        assert_eq!(classify("/usr/local/bin/node"), RouteTarget::Container);
        assert_eq!(classify("/usr/bin/git"), RouteTarget::Host);
    }

    #[test]
    fn generate_rc_contains_functions() {
        let rc = generate_rc("dual-lightfast-main", &[]);

        // Should contain the container name export
        assert!(rc.contains("export DUAL_CONTAINER=\"dual-lightfast-main\""));

        // Should contain functions for all container commands
        assert!(rc.contains("npm()"));
        assert!(rc.contains("npx()"));
        assert!(rc.contains("pnpm()"));
        assert!(rc.contains("node()"));
        assert!(rc.contains("python()"));
        assert!(rc.contains("curl()"));
    }

    #[test]
    fn generate_rc_has_tty_detection() {
        let rc = generate_rc("dual-lightfast-main", &[]);
        assert!(rc.contains("if [ -t 1 ]; then"));
        assert!(rc.contains("docker exec -t"));
    }

    #[test]
    fn generate_rc_uses_correct_container() {
        let rc = generate_rc("dual-agent-os-feat__memory", &[]);
        assert!(rc.contains("dual-agent-os-feat__memory"));
        // Every function should reference this container
        for cmd in CONTAINER_COMMANDS {
            assert!(rc.contains(&format!(
                "command docker exec -t -w /workspace dual-agent-os-feat__memory {cmd}"
            )));
        }
    }

    #[test]
    fn generate_rc_with_extra_commands() {
        let extras = vec!["cargo".to_string(), "go".to_string()];
        let rc = generate_rc("dual-test", &extras);
        assert!(rc.contains("cargo()"));
        assert!(rc.contains("go()"));
        // Default commands should still be present
        assert!(rc.contains("npm()"));
    }

    #[test]
    fn generate_rc_extra_commands_no_duplicates() {
        // If an extra command matches a default, it should not be duplicated
        let extras = vec!["npm".to_string(), "cargo".to_string()];
        let rc = generate_rc("dual-test", &extras);
        // Count "\nnpm() {" to avoid matching "pnpm() {" substring
        let npm_count = rc.matches("\nnpm() {").count();
        assert_eq!(npm_count, 1);
        assert!(rc.contains("cargo()"));
    }

    #[test]
    fn generated_function_preserves_args() {
        let func = generate_function("npm", "dual-test");
        assert!(func.contains("\"$@\""));
    }

    #[test]
    fn source_command_format() {
        let cmd = source_command("dual-lightfast-main");
        assert_eq!(cmd, "eval \"$(dual shell-rc dual-lightfast-main)\"");
    }

    #[test]
    fn write_rc_file_creates_file() {
        let path = write_rc_file("dual-test-write-rc", &[]).unwrap();
        assert!(path.exists());
        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("export DUAL_CONTAINER=\"dual-test-write-rc\""));
        assert!(content.contains("npm()"));
        // Clean up
        let _ = std::fs::remove_file(&path);
    }

    #[test]
    fn source_file_command_format() {
        let path = std::path::Path::new("/home/user/.config/dual/rc/dual-test.sh");
        let cmd = source_file_command(path);
        assert_eq!(cmd, "source /home/user/.config/dual/rc/dual-test.sh");
    }
}
